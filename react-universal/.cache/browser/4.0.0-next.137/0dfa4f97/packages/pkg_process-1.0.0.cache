{"sourceMap":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"\"}","contents":"FuseBox.pkg(\"process\", {}, function(___scope___){\n___scope___.file(\"index.js\", function(exports, require, module){\nif (FuseBox.isServer) {\n  if (typeof __process_env__ !== \"undefined\") {\n    Object.assign(global.process.env, __process_env__);\n  }\n  module.exports = global.process;\n} else {\n  if (typeof Object.assign != \"function\") {\n    Object.assign = function (target, varArgs) {\n      \"use strict\";\n      if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n      var to = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n        if (nextSource != null) {\n          for (var nextKey in nextSource) {\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n  var productionEnv = false;\n  var process = module.exports = {};\n  var queue = [];\n  var draining = false;\n  var currentQueue;\n  var queueIndex = -1;\n  function cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n      queue = currentQueue.concat(queue);\n    } else {\n      queueIndex = -1;\n    }\n    if (queue.length) {\n      drainQueue();\n    }\n  }\n  function drainQueue() {\n    if (draining) {\n      return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n    var len = queue.length;\n    while (len) {\n      currentQueue = queue;\n      queue = [];\n      while (++queueIndex < len) {\n        if (currentQueue) {\n          currentQueue[queueIndex].run();\n        }\n      }\n      queueIndex = -1;\n      len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n  }\n  process.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n      for (var i = 1; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n      setTimeout(drainQueue, 0);\n    }\n  };\n  function Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n  }\n  Item.prototype.run = function () {\n    this.fun.apply(null, this.array);\n  };\n  process.title = \"browser\";\n  process.browser = true;\n  process.env = FuseBox.processEnv;\n  if (typeof __process_env__ !== \"undefined\") {\n    Object.assign(process.env, __process_env__);\n  }\n  process.argv = [];\n  process.version = \"\";\n  process.versions = {};\n  function noop() {}\n  process.on = noop;\n  process.addListener = noop;\n  process.once = noop;\n  process.off = noop;\n  process.removeListener = noop;\n  process.removeAllListeners = noop;\n  process.emit = noop;\n  process.binding = function (name) {\n    throw new Error(\"process.binding is not supported\");\n  };\n  process.cwd = function () {\n    return \"/\";\n  };\n  process.chdir = function (dir) {\n    throw new Error(\"process.chdir is not supported\");\n  };\n  process.umask = function () {\n    return 0;\n  };\n}\n\n});\n\t___scope___.entry = \"index.js\";\n})"}