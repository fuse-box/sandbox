{"sourceMap":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"\"}","contents":"FuseBox.pkg(\"path-to-regexp\", {}, function(___scope___){\n___scope___.file(\"index.js\", function(exports, require, module){\nvar isarray = require(\"isarray\");\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\nvar PATH_REGEXP = new RegExp([\"(\\\\\\\\.)\", \"([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))\"].join(\"|\"), \"g\");\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = \"\";\n  var defaultDelimiter = options && options.delimiter || \"/\";\n  var res;\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n    if (path) {\n      tokens.push(path);\n      path = \"\";\n    }\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === \"+\" || modifier === \"*\";\n    var optional = modifier === \"?\" || modifier === \"*\";\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || \"\",\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? \".*\" : \"[^\" + escapeString(delimiter) + \"]+?\"\n    });\n  }\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n  if (path) {\n    tokens.push(path);\n  }\n  return tokens;\n}\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return \"%\" + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\nfunction tokensToFunction(tokens) {\n  var matches = new Array(tokens.length);\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === \"object\") {\n      matches[i] = new RegExp(\"^(?:\" + tokens[i].pattern + \")$\");\n    }\n  }\n  return function (obj, opts) {\n    var path = \"\";\n    var data = obj || ({});\n    var options = opts || ({});\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n      var value = data[token.name];\n      var segment;\n      if (value == null) {\n        if (token.optional) {\n          if (token.partial) {\n            path += token.prefix;\n          }\n          continue;\n        } else {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be defined\");\n        }\n      }\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but received `\" + JSON.stringify(value) + \"`\");\n        }\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n          }\n        }\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n          if (!matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but received `\" + JSON.stringify(segment) + \"`\");\n          }\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n        continue;\n      }\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n      if (!matches[i].test(segment)) {\n        throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but received \\\"\" + segment + \"\\\"\");\n      }\n      path += token.prefix + segment;\n    }\n    return path;\n  };\n}\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, \"\\\\$1\");\n}\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, \"\\\\$1\");\n}\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\nfunction flags(options) {\n  return options.sensitive ? \"\" : \"i\";\n}\nfunction regexpToRegexp(path, keys) {\n  var groups = path.source.match(/\\((?!\\?)/g);\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n  return attachKeys(path, keys);\n}\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n  var regexp = new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n  return attachKeys(regexp, keys);\n}\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = keys || options;\n    keys = [];\n  }\n  options = options || ({});\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = \"\";\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (typeof token === \"string\") {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = \"(?:\" + token.pattern + \")\";\n      keys.push(token);\n      if (token.repeat) {\n        capture += \"(?:\" + prefix + capture + \")*\";\n      }\n      if (token.optional) {\n        if (!token.partial) {\n          capture = \"(?:\" + prefix + \"(\" + capture + \"))?\";\n        } else {\n          capture = prefix + \"(\" + capture + \")?\";\n        }\n      } else {\n        capture = prefix + \"(\" + capture + \")\";\n      }\n      route += capture;\n    }\n  }\n  var delimiter = escapeString(options.delimiter || \"/\");\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + \"(?:\" + delimiter + \"(?=$))?\";\n  }\n  if (end) {\n    route += \"$\";\n  } else {\n    route += strict && endsWithDelimiter ? \"\" : \"(?=\" + delimiter + \"|$)\";\n  }\n  return attachKeys(new RegExp(\"^\" + route, flags(options)), keys);\n}\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options = keys || options;\n    keys = [];\n  }\n  options = options || ({});\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys);\n  }\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options);\n  }\n  return stringToRegexp(path, keys, options);\n}\n\n});\n\t___scope___.entry = \"index.js\";\n})"}