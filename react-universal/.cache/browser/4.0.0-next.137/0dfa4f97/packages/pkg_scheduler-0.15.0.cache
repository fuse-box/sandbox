{"sourceMap":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"\"}","contents":"FuseBox.pkg(\"scheduler\", {}, function(___scope___){\n___scope___.file(\"index.js\", function(exports, require, module){\nvar process = require(\"process\");\n\"use strict\";\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./cjs/scheduler.production.min.js\");\n} else {\n  module.exports = require(\"./cjs/scheduler.development.js\");\n}\n\n});\n___scope___.file(\"cjs/scheduler.production.min.js\", function(exports, require, module){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar d = void 0, e = void 0, g = void 0, m = void 0, n = void 0;\nexports.unstable_now = void 0;\nexports.unstable_forceFrameRate = void 0;\nif (\"undefined\" === typeof window || \"function\" !== typeof MessageChannel) {\n  var p = null, q = null, r = function () {\n    if (null !== p) try {\n      var a = exports.unstable_now();\n      p(!0, a);\n      p = null;\n    } catch (b) {\n      throw (setTimeout(r, 0), b);\n    }\n  };\n  exports.unstable_now = function () {\n    return Date.now();\n  };\n  d = function (a) {\n    null !== p ? setTimeout(d, 0, a) : (p = a, setTimeout(r, 0));\n  };\n  e = function (a, b) {\n    q = setTimeout(a, b);\n  };\n  g = function () {\n    clearTimeout(q);\n  };\n  m = function () {\n    return !1;\n  };\n  n = exports.unstable_forceFrameRate = function () {};\n} else {\n  var t = window.performance, u = window.Date, v = window.setTimeout, w = window.clearTimeout, x = window.requestAnimationFrame, y = window.cancelAnimationFrame;\n  \"undefined\" !== typeof console && (\"function\" !== typeof x && console.error(\"This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"), \"function\" !== typeof y && console.error(\"This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills\"));\n  exports.unstable_now = \"object\" === typeof t && \"function\" === typeof t.now ? function () {\n    return t.now();\n  } : function () {\n    return u.now();\n  };\n  var z = !1, A = null, B = -1, C = -1, D = 33.33, E = -1, F = -1, G = 0, H = !1;\n  m = function () {\n    return exports.unstable_now() >= G;\n  };\n  n = function () {};\n  exports.unstable_forceFrameRate = function (a) {\n    0 > a || 125 < a ? console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported\") : 0 < a ? (D = Math.floor(1000 / a), H = !0) : (D = 33.33, H = !1);\n  };\n  var J = function () {\n    if (null !== A) {\n      var a = exports.unstable_now(), b = 0 < G - a;\n      try {\n        A(b, a) || (A = null);\n      } catch (c) {\n        throw (I.postMessage(null), c);\n      }\n    }\n  }, K = new MessageChannel(), I = K.port2;\n  K.port1.onmessage = J;\n  var L = function (a) {\n    if (null === A) (F = E = -1, z = !1); else {\n      z = !0;\n      x(function (a) {\n        w(B);\n        L(a);\n      });\n      var b = function () {\n        G = exports.unstable_now() + D / 2;\n        J();\n        B = v(b, 3 * D);\n      };\n      B = v(b, 3 * D);\n      if (-1 !== E && 0.1 < a - E) {\n        var c = a - E;\n        !H && -1 !== F && c < D && F < D && (D = c < F ? F : c, 8.33 > D && (D = 8.33));\n        F = c;\n      }\n      E = a;\n      G = a + D;\n      I.postMessage(null);\n    }\n  };\n  d = function (a) {\n    A = a;\n    z || (z = !0, x(function (a) {\n      L(a);\n    }));\n  };\n  e = function (a, b) {\n    C = v(function () {\n      a(exports.unstable_now());\n    }, b);\n  };\n  g = function () {\n    w(C);\n    C = -1;\n  };\n}\nvar M = null, N = null, O = null, P = 3, Q = !1, R = !1, S = !1;\nfunction T(a, b) {\n  var c = a.next;\n  if (c === a) M = null; else {\n    a === M && (M = c);\n    var f = a.previous;\n    f.next = c;\n    c.previous = f;\n  }\n  a.next = a.previous = null;\n  c = a.callback;\n  f = P;\n  var l = O;\n  P = a.priorityLevel;\n  O = a;\n  try {\n    var h = a.expirationTime <= b;\n    switch (P) {\n      case 1:\n        var k = c(h);\n        break;\n      case 2:\n        k = c(h);\n        break;\n      case 3:\n        k = c(h);\n        break;\n      case 4:\n        k = c(h);\n        break;\n      case 5:\n        k = c(h);\n    }\n  } catch (Z) {\n    throw Z;\n  } finally {\n    (P = f, O = l);\n  }\n  if (\"function\" === typeof k) if ((b = a.expirationTime, a.callback = k, null === M)) M = a.next = a.previous = a; else {\n    k = null;\n    h = M;\n    do {\n      if (b <= h.expirationTime) {\n        k = h;\n        break;\n      }\n      h = h.next;\n    } while (h !== M);\n    null === k ? k = M : k === M && (M = a);\n    b = k.previous;\n    b.next = k.previous = a;\n    a.next = k;\n    a.previous = b;\n  }\n}\nfunction U(a) {\n  if (null !== N && N.startTime <= a) {\n    do {\n      var b = N, c = b.next;\n      if (b === c) N = null; else {\n        N = c;\n        var f = b.previous;\n        f.next = c;\n        c.previous = f;\n      }\n      b.next = b.previous = null;\n      V(b, b.expirationTime);\n    } while (null !== N && N.startTime <= a);\n  }\n}\nfunction W(a) {\n  S = !1;\n  U(a);\n  R || (null !== M ? (R = !0, d(X)) : null !== N && e(W, N.startTime - a));\n}\nfunction X(a, b) {\n  R = !1;\n  S && (S = !1, g());\n  U(b);\n  Q = !0;\n  try {\n    if (!a) for (; null !== M && M.expirationTime <= b; ) (T(M, b), b = exports.unstable_now(), U(b)); else if (null !== M) {\n      do (T(M, b), b = exports.unstable_now(), U(b)); while (null !== M && !m());\n    }\n    if (null !== M) return !0;\n    null !== N && e(W, N.startTime - b);\n    return !1;\n  } finally {\n    Q = !1;\n  }\n}\nfunction Y(a) {\n  switch (a) {\n    case 1:\n      return -1;\n    case 2:\n      return 250;\n    case 5:\n      return 1073741823;\n    case 4:\n      return 10000;\n    default:\n      return 5000;\n  }\n}\nfunction V(a, b) {\n  if (null === M) M = a.next = a.previous = a; else {\n    var c = null, f = M;\n    do {\n      if (b < f.expirationTime) {\n        c = f;\n        break;\n      }\n      f = f.next;\n    } while (f !== M);\n    null === c ? c = M : c === M && (M = a);\n    b = c.previous;\n    b.next = c.previous = a;\n    a.next = c;\n    a.previous = b;\n  }\n}\nvar aa = n;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_NormalPriority = 3;\nexports.unstable_IdlePriority = 5;\nexports.unstable_LowPriority = 4;\nexports.unstable_runWithPriority = function (a, b) {\n  switch (a) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      a = 3;\n  }\n  var c = P;\n  P = a;\n  try {\n    return b();\n  } finally {\n    P = c;\n  }\n};\nexports.unstable_next = function (a) {\n  switch (P) {\n    case 1:\n    case 2:\n    case 3:\n      var b = 3;\n      break;\n    default:\n      b = P;\n  }\n  var c = P;\n  P = b;\n  try {\n    return a();\n  } finally {\n    P = c;\n  }\n};\nexports.unstable_scheduleCallback = function (a, b, c) {\n  var f = exports.unstable_now();\n  if (\"object\" === typeof c && null !== c) {\n    var l = c.delay;\n    l = \"number\" === typeof l && 0 < l ? f + l : f;\n    c = \"number\" === typeof c.timeout ? c.timeout : Y(a);\n  } else (c = Y(a), l = f);\n  c = l + c;\n  a = {\n    callback: b,\n    priorityLevel: a,\n    startTime: l,\n    expirationTime: c,\n    next: null,\n    previous: null\n  };\n  if (l > f) {\n    c = l;\n    if (null === N) N = a.next = a.previous = a; else {\n      b = null;\n      var h = N;\n      do {\n        if (c < h.startTime) {\n          b = h;\n          break;\n        }\n        h = h.next;\n      } while (h !== N);\n      null === b ? b = N : b === N && (N = a);\n      c = b.previous;\n      c.next = b.previous = a;\n      a.next = b;\n      a.previous = c;\n    }\n    null === M && N === a && (S ? g() : S = !0, e(W, l - f));\n  } else (V(a, c), R || Q || (R = !0, d(X)));\n  return a;\n};\nexports.unstable_cancelCallback = function (a) {\n  var b = a.next;\n  if (null !== b) {\n    if (a === b) a === M ? M = null : a === N && (N = null); else {\n      a === M ? M = b : a === N && (N = b);\n      var c = a.previous;\n      c.next = b;\n      b.previous = c;\n    }\n    a.next = a.previous = null;\n  }\n};\nexports.unstable_wrapCallback = function (a) {\n  var b = P;\n  return function () {\n    var c = P;\n    P = b;\n    try {\n      return a.apply(this, arguments);\n    } finally {\n      P = c;\n    }\n  };\n};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return P;\n};\nexports.unstable_shouldYield = function () {\n  var a = exports.unstable_now();\n  U(a);\n  return null !== O && null !== M && M.startTime <= a && M.expirationTime < O.expirationTime || m();\n};\nexports.unstable_requestPaint = aa;\nexports.unstable_continueExecution = function () {\n  R || Q || (R = !0, d(X));\n};\nexports.unstable_pauseExecution = function () {};\nexports.unstable_getFirstCallbackNode = function () {\n  return M;\n};\n\n});\n___scope___.file(\"cjs/scheduler.development.js\", function(exports, require, module){\nvar process = require(\"process\");\n\"use strict\";\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var enableSchedulerDebugging = false;\n    var enableIsInputPending = false;\n    var requestIdleCallbackBeforeFirstFrame = false;\n    var requestTimerEventBeforeFirstFrame = false;\n    var enableMessageLoopImplementation = false;\n    var requestHostCallback = void 0;\n    var requestHostTimeout = void 0;\n    var cancelHostTimeout = void 0;\n    var shouldYieldToHost = void 0;\n    var requestPaint = void 0;\n    exports.unstable_now = void 0;\n    exports.unstable_forceFrameRate = void 0;\n    if (typeof window === \"undefined\" || typeof MessageChannel !== \"function\") {\n      var _callback = null;\n      var _timeoutID = null;\n      var _flushCallback = function () {\n        if (_callback !== null) {\n          try {\n            var currentTime = exports.unstable_now();\n            var hasRemainingTime = true;\n            _callback(hasRemainingTime, currentTime);\n            _callback = null;\n          } catch (e) {\n            setTimeout(_flushCallback, 0);\n            throw e;\n          }\n        }\n      };\n      exports.unstable_now = function () {\n        return Date.now();\n      };\n      requestHostCallback = function (cb) {\n        if (_callback !== null) {\n          setTimeout(requestHostCallback, 0, cb);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, 0);\n        }\n      };\n      requestHostTimeout = function (cb, ms) {\n        _timeoutID = setTimeout(cb, ms);\n      };\n      cancelHostTimeout = function () {\n        clearTimeout(_timeoutID);\n      };\n      shouldYieldToHost = function () {\n        return false;\n      };\n      requestPaint = exports.unstable_forceFrameRate = function () {};\n    } else {\n      var performance = window.performance;\n      var _Date = window.Date;\n      var _setTimeout = window.setTimeout;\n      var _clearTimeout = window.clearTimeout;\n      var requestAnimationFrame = window.requestAnimationFrame;\n      var cancelAnimationFrame = window.cancelAnimationFrame;\n      var requestIdleCallback = window.requestIdleCallback;\n      if (typeof console !== \"undefined\") {\n        if (typeof requestAnimationFrame !== \"function\") {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + \"Make sure that you load a \" + \"polyfill in older browsers. https://fb.me/react-polyfills\");\n        }\n        if (typeof cancelAnimationFrame !== \"function\") {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + \"Make sure that you load a \" + \"polyfill in older browsers. https://fb.me/react-polyfills\");\n        }\n      }\n      var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === \"function\" && typeof cancelIdleCallback === \"function\";\n      exports.unstable_now = typeof performance === \"object\" && typeof performance.now === \"function\" ? function () {\n        return performance.now();\n      } : function () {\n        return _Date.now();\n      };\n      var isRAFLoopRunning = false;\n      var isMessageLoopRunning = false;\n      var scheduledHostCallback = null;\n      var rAFTimeoutID = -1;\n      var taskTimeoutID = -1;\n      var frameLength = enableMessageLoopImplementation ? 5 : 33.33;\n      var prevRAFTime = -1;\n      var prevRAFInterval = -1;\n      var frameDeadline = 0;\n      var fpsLocked = false;\n      var maxFrameLength = 300;\n      var needsPaint = false;\n      if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\n        var scheduling = navigator.scheduling;\n        shouldYieldToHost = function () {\n          var currentTime = exports.unstable_now();\n          if (currentTime >= frameDeadline) {\n            if (needsPaint || scheduling.isInputPending()) {\n              return true;\n            }\n            return currentTime >= frameDeadline + maxFrameLength;\n          } else {\n            return false;\n          }\n        };\n        requestPaint = function () {\n          needsPaint = true;\n        };\n      } else {\n        shouldYieldToHost = function () {\n          return exports.unstable_now() >= frameDeadline;\n        };\n        requestPaint = function () {};\n      }\n      exports.unstable_forceFrameRate = function (fps) {\n        if (fps < 0 || fps > 125) {\n          console.error(\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing framerates higher than 125 fps is not unsupported\");\n          return;\n        }\n        if (fps > 0) {\n          frameLength = Math.floor(1000 / fps);\n          fpsLocked = true;\n        } else {\n          frameLength = 33.33;\n          fpsLocked = false;\n        }\n      };\n      var performWorkUntilDeadline = function () {\n        if (enableMessageLoopImplementation) {\n          if (scheduledHostCallback !== null) {\n            var currentTime = exports.unstable_now();\n            frameDeadline = currentTime + frameLength;\n            var hasTimeRemaining = true;\n            try {\n              var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n              if (!hasMoreWork) {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n              } else {\n                port.postMessage(null);\n              }\n            } catch (error) {\n              port.postMessage(null);\n              throw error;\n            }\n          }\n          needsPaint = false;\n        } else {\n          if (scheduledHostCallback !== null) {\n            var _currentTime = exports.unstable_now();\n            var _hasTimeRemaining = frameDeadline - _currentTime > 0;\n            try {\n              var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\n              if (!_hasMoreWork) {\n                scheduledHostCallback = null;\n              }\n            } catch (error) {\n              port.postMessage(null);\n              throw error;\n            }\n          }\n          needsPaint = false;\n        }\n      };\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      var onAnimationFrame = function (rAFTime) {\n        if (scheduledHostCallback === null) {\n          prevRAFTime = -1;\n          prevRAFInterval = -1;\n          isRAFLoopRunning = false;\n          return;\n        }\n        isRAFLoopRunning = true;\n        requestAnimationFrame(function (nextRAFTime) {\n          _clearTimeout(rAFTimeoutID);\n          onAnimationFrame(nextRAFTime);\n        });\n        var onTimeout = function () {\n          frameDeadline = exports.unstable_now() + frameLength / 2;\n          performWorkUntilDeadline();\n          rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n        };\n        rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n        if (prevRAFTime !== -1 && rAFTime - prevRAFTime > 0.1) {\n          var rAFInterval = rAFTime - prevRAFTime;\n          if (!fpsLocked && prevRAFInterval !== -1) {\n            if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n              frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n              if (frameLength < 8.33) {\n                frameLength = 8.33;\n              }\n            }\n          }\n          prevRAFInterval = rAFInterval;\n        }\n        prevRAFTime = rAFTime;\n        frameDeadline = rAFTime + frameLength;\n        port.postMessage(null);\n      };\n      requestHostCallback = function (callback) {\n        scheduledHostCallback = callback;\n        if (enableMessageLoopImplementation) {\n          if (!isMessageLoopRunning) {\n            isMessageLoopRunning = true;\n            port.postMessage(null);\n          }\n        } else {\n          if (!isRAFLoopRunning) {\n            isRAFLoopRunning = true;\n            requestAnimationFrame(function (rAFTime) {\n              if (requestIdleCallbackBeforeFirstFrame$1) {\n                cancelIdleCallback(idleCallbackID);\n              }\n              if (requestTimerEventBeforeFirstFrame) {\n                _clearTimeout(idleTimeoutID);\n              }\n              onAnimationFrame(rAFTime);\n            });\n            var idleCallbackID = void 0;\n            if (requestIdleCallbackBeforeFirstFrame$1) {\n              idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\n                if (requestTimerEventBeforeFirstFrame) {\n                  _clearTimeout(idleTimeoutID);\n                }\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              });\n            }\n            var idleTimeoutID = void 0;\n            if (requestTimerEventBeforeFirstFrame) {\n              idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\n                if (requestIdleCallbackBeforeFirstFrame$1) {\n                  cancelIdleCallback(idleCallbackID);\n                }\n                frameDeadline = exports.unstable_now() + frameLength;\n                performWorkUntilDeadline();\n              }, 0);\n            }\n          }\n        }\n      };\n      requestHostTimeout = function (callback, ms) {\n        taskTimeoutID = _setTimeout(function () {\n          callback(exports.unstable_now());\n        }, ms);\n      };\n      cancelHostTimeout = function () {\n        _clearTimeout(taskTimeoutID);\n        taskTimeoutID = -1;\n      };\n    }\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    var maxSigned31BitInt = 1073741823;\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000;\n    var IDLE_PRIORITY = maxSigned31BitInt;\n    var firstTask = null;\n    var firstDelayedTask = null;\n    var isSchedulerPaused = false;\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority;\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false;\n    function scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n    function flushTask(task, currentTime) {\n      var next = task.next;\n      if (next === task) {\n        firstTask = null;\n      } else {\n        if (task === firstTask) {\n          firstTask = next;\n        }\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n      var callback = task.callback;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousTask = currentTask;\n      currentPriorityLevel = task.priorityLevel;\n      currentTask = task;\n      var continuationCallback;\n      try {\n        var didUserCallbackTimeout = task.expirationTime <= currentTime;\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n            break;\n          case UserBlockingPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n            break;\n          case NormalPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n            break;\n          case LowPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n            break;\n          case IdlePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n            break;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentTask = previousTask;\n      }\n      if (typeof continuationCallback === \"function\") {\n        var expirationTime = task.expirationTime;\n        var continuationTask = task;\n        continuationTask.callback = continuationCallback;\n        if (firstTask === null) {\n          firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n        } else {\n          var nextAfterContinuation = null;\n          var t = firstTask;\n          do {\n            if (expirationTime <= t.expirationTime) {\n              nextAfterContinuation = t;\n              break;\n            }\n            t = t.next;\n          } while (t !== firstTask);\n          if (nextAfterContinuation === null) {\n            nextAfterContinuation = firstTask;\n          } else if (nextAfterContinuation === firstTask) {\n            firstTask = continuationTask;\n          }\n          var _previous = nextAfterContinuation.previous;\n          _previous.next = nextAfterContinuation.previous = continuationTask;\n          continuationTask.next = nextAfterContinuation;\n          continuationTask.previous = _previous;\n        }\n      }\n    }\n    function advanceTimers(currentTime) {\n      if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n        do {\n          var task = firstDelayedTask;\n          var next = task.next;\n          if (task === next) {\n            firstDelayedTask = null;\n          } else {\n            firstDelayedTask = next;\n            var previous = task.previous;\n            previous.next = next;\n            next.previous = previous;\n          }\n          task.next = task.previous = null;\n          insertScheduledTask(task, task.expirationTime);\n        } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (firstTask !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else if (firstDelayedTask !== null) {\n          requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      }\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      isPerformingWork = true;\n      try {\n        if (!hasTimeRemaining) {\n          while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n            flushTask(firstTask, currentTime);\n            currentTime = exports.unstable_now();\n            advanceTimers(currentTime);\n          }\n        } else {\n          if (firstTask !== null) {\n            do {\n              flushTask(firstTask, currentTime);\n              currentTime = exports.unstable_now();\n              advanceTimers(currentTime);\n            } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n          }\n        }\n        if (firstTask !== null) {\n          return true;\n        } else {\n          if (firstDelayedTask !== null) {\n            requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n          }\n          return false;\n        }\n      } finally {\n        isPerformingWork = false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function timeoutForPriorityLevel(priorityLevel) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          return IMMEDIATE_PRIORITY_TIMEOUT;\n        case UserBlockingPriority:\n          return USER_BLOCKING_PRIORITY;\n        case IdlePriority:\n          return IDLE_PRIORITY;\n        case LowPriority:\n          return LOW_PRIORITY_TIMEOUT;\n        case NormalPriority:\n        default:\n          return NORMAL_PRIORITY_TIMEOUT;\n      }\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      var timeout;\n      if (typeof options === \"object\" && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === \"number\" && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n        timeout = typeof options.timeout === \"number\" ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n      } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n      if (startTime > currentTime) {\n        insertDelayedTask(newTask, startTime);\n        if (firstTask === null && firstDelayedTask === newTask) {\n          if (isHostTimeoutScheduled) {\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          }\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        insertScheduledTask(newTask, expirationTime);\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function insertScheduledTask(newTask, expirationTime) {\n      if (firstTask === null) {\n        firstTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstTask;\n        do {\n          if (expirationTime < task.expirationTime) {\n            next = task;\n            break;\n          }\n          task = task.next;\n        } while (task !== firstTask);\n        if (next === null) {\n          next = firstTask;\n        } else if (next === firstTask) {\n          firstTask = newTask;\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n    function insertDelayedTask(newTask, startTime) {\n      if (firstDelayedTask === null) {\n        firstDelayedTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstDelayedTask;\n        do {\n          if (startTime < task.startTime) {\n            next = task;\n            break;\n          }\n          task = task.next;\n        } while (task !== firstDelayedTask);\n        if (next === null) {\n          next = firstDelayedTask;\n        } else if (next === firstDelayedTask) {\n          firstDelayedTask = newTask;\n        }\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return firstTask;\n    }\n    function unstable_cancelCallback(task) {\n      var next = task.next;\n      if (next === null) {\n        return;\n      }\n      if (task === next) {\n        if (task === firstTask) {\n          firstTask = null;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = null;\n        }\n      } else {\n        if (task === firstTask) {\n          firstTask = next;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = next;\n        }\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    function unstable_shouldYield() {\n      var currentTime = exports.unstable_now();\n      advanceTimers(currentTime);\n      return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n    }\n    var unstable_requestPaint = requestPaint;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n\n});\n___scope___.file(\"tracing.js\", function(exports, require, module){\nvar process = require(\"process\");\n\"use strict\";\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./cjs/scheduler-tracing.production.min.js\");\n} else {\n  module.exports = require(\"./cjs/scheduler-tracing.development.js\");\n}\n\n});\n___scope___.file(\"cjs/scheduler-tracing.production.min.js\", function(exports, require, module){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar b = 0;\nexports.__interactionsRef = null;\nexports.__subscriberRef = null;\nexports.unstable_clear = function (a) {\n  return a();\n};\nexports.unstable_getCurrent = function () {\n  return null;\n};\nexports.unstable_getThreadID = function () {\n  return ++b;\n};\nexports.unstable_trace = function (a, d, c) {\n  return c();\n};\nexports.unstable_wrap = function (a) {\n  return a;\n};\nexports.unstable_subscribe = function () {};\nexports.unstable_unsubscribe = function () {};\n\n});\n___scope___.file(\"cjs/scheduler-tracing.development.js\", function(exports, require, module){\nvar process = require(\"process\");\n\"use strict\";\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    var enableSchedulerTracing = true;\n    var DEFAULT_THREAD_ID = 0;\n    var interactionIDCounter = 0;\n    var threadIDCounter = 0;\n    exports.__interactionsRef = null;\n    exports.__subscriberRef = null;\n    if (enableSchedulerTracing) {\n      exports.__interactionsRef = {\n        current: new Set()\n      };\n      exports.__subscriberRef = {\n        current: null\n      };\n    }\n    function unstable_clear(callback) {\n      if (!enableSchedulerTracing) {\n        return callback();\n      }\n      var prevInteractions = exports.__interactionsRef.current;\n      exports.__interactionsRef.current = new Set();\n      try {\n        return callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n      }\n    }\n    function unstable_getCurrent() {\n      if (!enableSchedulerTracing) {\n        return null;\n      } else {\n        return exports.__interactionsRef.current;\n      }\n    }\n    function unstable_getThreadID() {\n      return ++threadIDCounter;\n    }\n    function unstable_trace(name, timestamp, callback) {\n      var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n      if (!enableSchedulerTracing) {\n        return callback();\n      }\n      var interaction = {\n        __count: 1,\n        id: interactionIDCounter++,\n        name: name,\n        timestamp: timestamp\n      };\n      var prevInteractions = exports.__interactionsRef.current;\n      var interactions = new Set(prevInteractions);\n      interactions.add(interaction);\n      exports.__interactionsRef.current = interactions;\n      var subscriber = exports.__subscriberRef.current;\n      var returnValue = void 0;\n      try {\n        if (subscriber !== null) {\n          subscriber.onInteractionTraced(interaction);\n        }\n      } finally {\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStarted(interactions, threadID);\n          }\n        } finally {\n          try {\n            returnValue = callback();\n          } finally {\n            exports.__interactionsRef.current = prevInteractions;\n            try {\n              if (subscriber !== null) {\n                subscriber.onWorkStopped(interactions, threadID);\n              }\n            } finally {\n              interaction.__count--;\n              if (subscriber !== null && interaction.__count === 0) {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              }\n            }\n          }\n        }\n      }\n      return returnValue;\n    }\n    function unstable_wrap(callback) {\n      var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n      if (!enableSchedulerTracing) {\n        return callback;\n      }\n      var wrappedInteractions = exports.__interactionsRef.current;\n      var subscriber = exports.__subscriberRef.current;\n      if (subscriber !== null) {\n        subscriber.onWorkScheduled(wrappedInteractions, threadID);\n      }\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count++;\n      });\n      var hasRun = false;\n      function wrapped() {\n        var prevInteractions = exports.__interactionsRef.current;\n        exports.__interactionsRef.current = wrappedInteractions;\n        subscriber = exports.__subscriberRef.current;\n        try {\n          var returnValue = void 0;\n          try {\n            if (subscriber !== null) {\n              subscriber.onWorkStarted(wrappedInteractions, threadID);\n            }\n          } finally {\n            try {\n              returnValue = callback.apply(undefined, arguments);\n            } finally {\n              exports.__interactionsRef.current = prevInteractions;\n              if (subscriber !== null) {\n                subscriber.onWorkStopped(wrappedInteractions, threadID);\n              }\n            }\n          }\n          return returnValue;\n        } finally {\n          if (!hasRun) {\n            hasRun = true;\n            wrappedInteractions.forEach(function (interaction) {\n              interaction.__count--;\n              if (subscriber !== null && interaction.__count === 0) {\n                subscriber.onInteractionScheduledWorkCompleted(interaction);\n              }\n            });\n          }\n        }\n      }\n      wrapped.cancel = function cancel() {\n        subscriber = exports.__subscriberRef.current;\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkCanceled(wrappedInteractions, threadID);\n          }\n        } finally {\n          wrappedInteractions.forEach(function (interaction) {\n            interaction.__count--;\n            if (subscriber && interaction.__count === 0) {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            }\n          });\n        }\n      };\n      return wrapped;\n    }\n    var subscribers = null;\n    if (enableSchedulerTracing) {\n      subscribers = new Set();\n    }\n    function unstable_subscribe(subscriber) {\n      if (enableSchedulerTracing) {\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n          exports.__subscriberRef.current = {\n            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n            onInteractionTraced: onInteractionTraced,\n            onWorkCanceled: onWorkCanceled,\n            onWorkScheduled: onWorkScheduled,\n            onWorkStarted: onWorkStarted,\n            onWorkStopped: onWorkStopped\n          };\n        }\n      }\n    }\n    function unstable_unsubscribe(subscriber) {\n      if (enableSchedulerTracing) {\n        subscribers.delete(subscriber);\n        if (subscribers.size === 0) {\n          exports.__subscriberRef.current = null;\n        }\n      }\n    }\n    function onInteractionTraced(interaction) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onInteractionTraced(interaction);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    function onInteractionScheduledWorkCompleted(interaction) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    function onWorkScheduled(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkScheduled(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    function onWorkStarted(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkStarted(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    function onWorkStopped(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkStopped(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    function onWorkCanceled(interactions, threadID) {\n      var didCatchError = false;\n      var caughtError = null;\n      subscribers.forEach(function (subscriber) {\n        try {\n          subscriber.onWorkCanceled(interactions, threadID);\n        } catch (error) {\n          if (!didCatchError) {\n            didCatchError = true;\n            caughtError = error;\n          }\n        }\n      });\n      if (didCatchError) {\n        throw caughtError;\n      }\n    }\n    exports.unstable_clear = unstable_clear;\n    exports.unstable_getCurrent = unstable_getCurrent;\n    exports.unstable_getThreadID = unstable_getThreadID;\n    exports.unstable_trace = unstable_trace;\n    exports.unstable_wrap = unstable_wrap;\n    exports.unstable_subscribe = unstable_subscribe;\n    exports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n\n});\n\t___scope___.entry = \"index.js\";\n})"}